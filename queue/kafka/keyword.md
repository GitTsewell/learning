### 保证消息队列可靠性
既不多发,也不少发
1. 多发一般不会出现,一般是生产者自己问题,需要保证的就是消费者控制,消费端实现幂等性
2. 少发就是消息丢失.
+ 确保持久化到了broker
+ 确保消费端消费没问题再发送ack

### 死信队列 和 延时队列
kafka不支持

### kafka副本同步机制
主备模式,follow节点平时不负责R/W 只是备份
* [kafka副本同步机制](https://juejin.cn/post/6844903864911544334)


### kafka高性能高吞吐原因
1. 顺序写.kafka都是append操作,利用磁盘的顺序访问速度接近内存,节省磁盘寻址空间
2. 零拷贝.读取数据一般都是从磁盘文件读出来放到Read Buffer中,然后再将数据复制到网卡设备中传送.而kafka将数据直接从磁盘文件复制到网卡设备中，而不需要经由应用程序之手
3. 容量大. 因为直接在磁盘中采用顺序写,比在内存中写容量更大
4. 分区,分段加上稀疏文件索引达到根据offset快速查找数据能力,实现高性能查询
5. 批量压缩,批量读取
* [Kafka 中所谓的 ‘零拷贝’ 技术到底是什么](https://segmentfault.com/a/1190000039293191)
* [kafka分区、分段、稀疏索引实现高性能查询](https://www.jianshu.com/p/255de4d3874b)

### kafka丢失消息场景已经解决方案
* [kafka消息重复和丢失的场景及解决方案分析](https://blog.csdn.net/qq_39188150/article/details/111415881)


### kafka pull优劣势
#### 优势
1. 根据consumer的消费能力进行拉取,控制速率
2. 可以批量拉取,也可以单条拉取
3. 设置不同的提交方式,实现不同的传输语义

#### 劣势
1. 如果kafka没有数据,会导致consumer空循环