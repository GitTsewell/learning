## 锁
### 6.1 全局锁
Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候,可以使用这个命令.

使用场景:做全库逻辑备份的时候.当然让全库只读,听上去就很危险

当然如果你的引擎是innodb,由于有mvcc的支持,可以在备份开始前开始事务,确保拿到一致性的数据

### 6.2 表锁
MySQL里面表级别的锁有两种:一种是表锁,一种是元数据锁(meta data lock,MDL)。

表锁的语法是 lock tables ...read/write。与FTWRL类似,可以用unlock tables主动释放锁,
也可以在客户端断开的时候自动释放。需要注意,lock tables语法除了会限制别的线程的读写
外,也限定了本线程接下来的操作对象。

另一类表级的锁是MDL(metadata lock)。MDL不需要显式使用,在访问一个表的时候会被
自动加上。MDL的作用是,保证读写的正确性。你可以想象一下,如果一个查询正在遍历一个
表中的数据,而执行期间另一个线程对这个表结构做变更,删了一列,那么查询线程拿到的结果
跟表结构对不上,肯定是不行的。

### 6.3 行锁
在InnoDB事务中,行锁是在需要的时候才加上的,但并不是不需要了就立刻释
放,而是要等到事务结束时才释放。这个就是两阶段锁协议。

#### 6.3.1 死锁和死锁检测
两种策略:
+ 一种策略是,直接进入等待,直到超时。这个超时时间可以通过参数
innodb_lock_wait_timeout来设置。
+ 另一种策略是,发起死锁检测,发现死锁后,主动回滚死锁链条中的某一个事务,让其他事
务得以继续执行。将参数innodb_deadlock_detect设置为on,表示开启这个逻辑。