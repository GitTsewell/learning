## 日志模块
### 2.1 redo log (重做日志) --- WAL技术
有更新或者插入,先在粉板上记录信息,如果粉板满了,在把粉板上面的记录记在账本上面,然后把粉板差掉.

而粉板和账本配合的整个过程,其实就是MySQL里经常说到的WAL技术,WAL的全称是Write-
Ahead Logging,它的关键点就是先写日志,再写磁盘,也就是先写粉板,等不忙的时候再写账本。

具体来说,当有一条记录需要更新的时候,InnoDB引擎就会先把记录写到redo log(粉板)里
面,并更新内存,这个时候更新就算完成了。同时,InnoDB引擎会在适当的时候,将这个操作
记录更新到磁盘里面,而这个更新往往是在系统比较空闲的时候做,这就像打烊以后掌柜做的事。

redo log的三种状态 :
1. 存在redo log buffer中，物理上在MySQL进程内存中；
2. 写到磁盘write, 但是没有持久化fsync,物理上是在文件系统的page cache里面;
3. 持久化到磁盘，对应的是hard disk.

日志写到 redo log buffer 是很快的，wirte 到 page cache 也差不多，但是持久化到磁盘的速度就慢多了。

InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘

为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数，控制redo log 的刷新。它有三种可能取值：

1. 设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ; 这样可能丢失1s的事务数据。
2. 设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；这样的话，数据库对IO的要求非常高，如果底层硬件提供的IOPS比较差，MySQL数据库 并发很快就会由于硬件IO的问题而无法提升。（当然，InnoDB的组提交方法为降低IOPS做了很大优化）
3. 设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。如果只是MySQL数据库挂掉了，由于文件系统没有问题，那么对应的事务数据并没有丢失。只有在数据库所在的主机操作系统损坏或者突然掉电的情况下，数据库的事务数据可能丢失1秒之类的事务数据。这样的好处就是，减少了事务数据丢失的概率，而对底层硬件的IO要求也没有那么高(log buffer写到文件系统中，一般只是从log buffer的内存转移的文件系统的内存缓存中，对底层IO没有压力)

Mysql 默认是设置是1,也就是直接把redo log 持久化到磁盘

### 2.2 bin log (重要的日志模块)
前面我们讲过,MySQL整体来看,其实就有两块:一块是Server层,它主要做的是MySQL功能
层面的事情;还有一块是引擎层,负责存储相关的具体事宜。上面我们聊到的粉板redo log是
InnoDB引擎特有的日志,而Server层也有自己的日志,称为binlog(归档日志)。

这两种日志有以下三点不同。
1. redo log是InnoDB引擎特有的;binlog是MySQL的Server层实现的,所有引擎都可以使用。
2. redo log是物理日志,记录的是“在某个数据页上做了什么修改”;binlog是逻辑日志,记录的
是这个语句的原始逻辑,比如“给ID=2这一行的c字段加1 ”。
3. redo log是循环写的,空间固定会用完;binlog是可以追加写入的。“追加写”是指binlog文件
写到一定大小后会切换到下一个,并不会覆盖以前的日志。

有了对这两个日志的概念性理解,我们再来看执行器和InnoDB引擎在执行这个简单的update语
句时的内部流程。
1. 执行器先找引擎取ID=2这一行。ID是主键,引擎直接用树搜索找到这一行。如果ID=2这一
行所在的数据页本来就在内存中,就直接返回给执行器;否则,需要先从磁盘读入内存,然
后再返回。
2. 执行器拿到引擎给的行数据,把这个值加上1,比如原来是N,现在就是N+1,得到新的一行
数据,再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中,同时将这个更新操作记录到redo log里面,此时redo log处
于prepare状态。然后告知执行器执行完成了,随时可以提交事务。
4. 执行器生成这个操作的binlog,并把binlog写入磁盘。
5. 执行器调用引擎的提交事务接口,引擎把刚刚写入的redo log改成提交(commit)状态,更
新完成。

你可能注意到了,最后三步看上去有点“绕”,将redo log的写入拆成了两个步骤:prepare和
commit,这就是"两阶段提交"。

### 2.3 两阶段提交
当commit 命令执行时，
1. 先进入commit prepare 阶段，这个阶段事务中新生成的redo log 会被刷到磁盘，并将回滚段置为prepared状态。
2. commit阶段：innodb释放锁，释放回滚段，设置redo log提交状态，binlog持久化到磁盘，然后存储引擎层提交。

#### 2.3.1 为什么需要二阶段提交
由于存在redo log 和 binlog ，而他们两是相互独立的。而事务提交必须确保两者同时有效。不然会出现不一致的情形。假如： 
+ redo log 有效，binlog 无对应记录在上述例子中如果服务器从事务中回复，由于redo log 有效所以id为10的记录age仍然会是10，但是由于binlog日志没有记录，所以如果通过binlog 做主从，或者主备那么就会导致主从，主备不一致。
+ redo log 失效，而binlog 有对应记录，上述例子中，服务器中对应的id为10的日志age就会是修改前的5，而binlog中的日志会被传到其他从服务器，也会导致主从，主备不一致。

#### 2.3.2 redo log 和bin log 如何联系起来
它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：
+ 如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；
+ 如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。




