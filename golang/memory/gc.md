* [Golang三色标记+混合写屏障GC模式全分析](https://github.com/aceld/golang/blob/main/5%E3%80%81Golang%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%2B%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9CGC%E6%A8%A1%E5%BC%8F%E5%85%A8%E5%88%86%E6%9E%90.md)

## 发展流程

### 标记
STW停止整个程序,从根节点开始遍历标记. STW-->遍历-->标记-->清除--> 恢复,STW影响性能,后来改成 STW-->遍历-->标记--> 恢复 --> 清除,虽然简短清除时间,不过性能依旧不好

这个阶段首要问题就是解决STW带来的程序阻塞

### 三色标记法
黑色(已扫描过),灰色(这轮正准备扫描),白色(未扫描),依旧从根节点开始遍历,按照广度优先算法,一层一层扫描,直到所有节点没有灰色节点,这种方式可以边扫描程序边工作 基本不用STW

问题:由于是边扫描程序边工作,如果这个时候黑色节点指向一个白色节点A,然后另一个白色或灰色节点把指向白色节点A的引用删除,那就会造成这轮白色节点命名有引用却被删除.

解决: 提出强-弱三色不变式
1. 强三色不变式：不允许黑色对象指向白色对象
2. 弱三色不变式: 允许黑色对象指向白色对象.但是这个白色对象必须处于灰色对象的保护之中

### 插入删除屏障
为了解决强-弱三色不变式的问题,提出了插入删除屏障

1. 插入屏障 : 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色),注意插入屏障技术只在堆空间使用,因为栈空间的特点是容量小，但是要求响应速度快，因为函数调用弹出频繁使用；
栈空间依旧是STW重新标记

2. 删除屏障 : 具体操作: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。

问题: 一: 栈空间依旧有STW,虽然相比以前已经快很多,但依旧有10~100ms的暂停; 二 : 删除屏障会让很多本来该在这一轮回收的对象免于回收,回收精度低.

### 混合写屏障
1. GC开始将栈上的对象全部引用扫描并标记为黑色 (之后不再进行第二次重复扫描，无需STW)。
2.GC期间，任何在栈上创建的新对象，均为黑色（保证栈全为黑色对象）。
3. 被删除的对象标记为灰色（插入写屏障）。
4. 被添加的对象标记为灰色（删除写屏障）


## 垃圾收集的多个阶段
1. 清理终止阶段；z
  + 暂停程序，所有的处理器在这时会进入安全点（Safe point）；
  +  如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；
2. 标记阶段；
  + 将状态切换至 _GCmark、开启写屏障、用户程序协助（Mutator Assists）并将根对象入队；
  + 恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；
  + 开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；
  + 依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；
  + 使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；
3. 标记终止阶段；
  + 暂停程序、将状态切换至 _GCmarktermination 并关闭辅助标记的用户程序；
  + 清理处理器上的线程缓存；
4. 清理阶段；
  + 将状态切换至 _GCoff 开始清理阶段，初始化清理状态并关闭写屏障；
  + 恢复用户程序，所有新创建的对象会标记成白色；
  + 后台并发清理所有的内存管理单元，当 Goroutine 申请新的内存管理单元时就会触发清理；

## 触发时间
1. runtime.sysmon 和 runtime.forcegchelper — 后台运行定时检查和垃圾收集；
2. runtime.GC — 用户程序手动触发垃圾收集；
3. runtime.mallocgc — 申请内存时根据堆大小触发垃圾收集；

