## 浮点数

### 1.浮点数在计算机底层存储机制
单精度浮点数float占4字节32位，双精度浮点数double占8字节64位。float和double的二进制存储结构都是：符号位+指数位+尾数位

#### float32
| 符号位  | 指数位  | 尾数位  |
| ------------ | ------------ | ------------ |
|  1 | 8  |  23 |

#### float64

| 符号位  | 指数位  | 尾数位  |
| ------------ | ------------ | ------------ |
|  1 | 11 |  52 |


比如6.125转化为单精度的二进制
+ 整数部分5-->110
+ 小数部分x2取整,正序排列 
```
0.125 * 2  0
0.25 * 2   0
0.5 * 2    1
```

1. 符号位 正数为0 负数为1
2. 指数位 小数部分等于101, 结果为110.001 科学计数法表示 1.10001 * 2^2,所以指数为2,由于指数也分正负 2^8 范围是-127 ~ 128 正数需要 + 127  指数位等于127+2 = 129 转化为二进制为 10000001 
3. 尾数位 1.10001 小数位前面的不需要 后面补齐 所以尾数位为 10001000000000000000000
4. 最终6.125的二进制表示为 01000000110001000000000000000000


### 2.浮点数的计算机底层加法运算过程

我们都知道float64 中 0.1 + 0.2 != 0.3 那么就来看一下浮点数计算的过程

1. 首先把0.1和0.2 分别转换成二进制表示为
```
0.1   0 01111111011 1001100110011001100110011001100110011001100110011010
0.2   0 01111111100 1001100110011001100110011001100110011001100110011010
```

2. 指数位对阶 一般是用小的指数减去大的 01111111011 - 01111111100 = -1 所以0.1 的尾数位右移一位 (tips:浮点数尾数位隐藏位默认是1)
```
0.1尾数位  1.1001100110011001100110011001100110011001100110011010 右移一位
得到 0.1100110011001100110011001100110011001100110011001101(0)
按照0舍1进, 0舍去,所以得到  
0.1100110011001100110011001100110011001100110011001101

0.1 和0.2 的尾数相加得到
1.1001100110011001100110011001100110011001100110011010
0.1100110011001100110011001100110011001100110011001101
10.0110011001100110011001100110011001100110011001100111
```

3. 正规化 根据正规化要求,我们把结果右移一位,并且指数位+1
```
1.0011001100110011001100110011001100110011001100110011(1)
进1
1.0011001100110011001100110011001100110011001100110100
```

4. 最后得到的二进制为 
```
0 01111111101 0011001100110011001100110011001100110011001100110100
转化十进制
0.30000000000000004
```

所以现在知道为什么 0.1 + 0.2 != 0.3 了吧

### 参考资料和工具
+ [浮点数的加法](https://blog.csdn.net/m0_37972557/article/details/84594879)
+ [IEEE 754单精度在线计算](http://www.styb.cn/cms/ieee_754.php)
+ [在线进度转换](https://tool.lu/hexconvert/)
+ [解决float精度的方案](https://draveness.me/whys-the-design-decimal-and-rational/)