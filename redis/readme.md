<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->

* [数据结构](#数据结构)
* [分布式锁](#分布式锁)
* [假如Redis里面有1亿个key,其中有10w个key是以某个固定的已知的前缀开头的,如果将它们全部找出来](#假如Redis里面有1亿个key其中有10w个key是以某个固定的已知的前缀开头的如果将它们全部找出来)
* [如果有大量的key需要设置同一时间过期,一般需要注意什么](#如果有大量的key需要设置同一时间过期一般需要注意什么)
* [持久化](#持久化)
* [Redis的同步机制](#Redis的同步机制)
* [Redis集群](#Redis集群)
* [Pipeline有什么好处，为什么要用pipeline](#Pipeline有什么好处为什么要用pipeline)
* [Redis雪崩、穿透和击穿](#Redis雪崩穿透和击穿)

<!-- markdown-toc end -->

# 数据结构
字符串String、字典Hash、列表List、集合Set、有序集合SortedSet。  
如果你是Redis中高级用户，还需要加上下面几种数据结构HyperLogLog、Geo、Pub/Sub。  
如果你说还玩过Redis Module，像BloomFilter，RedisSearch，Redis-ML，面试官得眼睛就开始发亮了  

## 字符串
redis的字符串是动态字符串,采用的是预分配冗余空间的方式,如果长度小于1m ,扩容加倍现有空间,如果大于1m,每次扩容增加1m,最大长度是512m

## list(列表)
redis的列表是链表结构,插入和删除速度非常快,时间复杂度是O(1),但是索引定位很慢是O(n),当列表弹出最后一个元素之后,该数据结构自动被删除,内存被回收

## hash(字典)
redis的hash结构同样是数组+链表的二维结构,第一维hash的数组位置碰撞时,就会将碰撞的元素使用链表串接起来,然后redis的rehash和其他一些语言处理方式不同,一般rehash是一个耗时的操作,redis为了高性能,采用的是渐进式的,渐进式的rehash会同时保留新旧两个hash结构,查询任然会查询到两个hash结构,然后再后续的定时任务以及hash操作中,循序渐进地将就结构的hash一点点迁移到新的hash结构中,当搬迁完成了,就会用新的hash结构取代

## set(集合)
redis的set内部键值对是无序的唯一的,内部实现相当于一个特殊的字典,字典中的所有value都是一个值null

## zset(有序集合)
zset可能是redis提供最为特殊的数据结构,一方面他是个set,保证内部value的唯一性,另一方面它可以给每个value赋予一个score,代表这个value的排序权重,这个内部使用跳跃列表的数据结构  
redis内部跳跃列表的具体实现(#https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5ac63d5188256255299d9c)

# 分布式锁
1. 先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。
2. 第一步并不是原子性操作,如果中途挂了 锁将永远得不到释放 ,在redis2.8版本以后,有一个可以把setnx 和expire一起执行的语句
3. 锁超时问题,第二步中如果程序执行时间太长,锁过期失效,第二个程序就会进来,然后如果这个时候第一个程序执行完毕把锁释放了(这个时候它释放的其实不是自己的锁,而是第二个程序的锁),之后执行顺序完全乱套了,这个时候可以设置一个随机数,确定是一样的才释放锁,但是这个时候,匹配锁和删除锁又不是一个原子操作了,需要借助lua脚本来实现
   
# 假如Redis里面有1亿个key,其中有10w个key是以某个固定的已知的前缀开头的,如果将它们全部找出来
使用keys指令可以扫出指定模式的key列表,但是数据太多keys会导致线程阻塞,这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。

# 如果有大量的key需要设置同一时间过期,一般需要注意什么
如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。

# 持久化
bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，优先使用aof来恢复内存的状态，如果没有aof日志，就会使用rdb文件来恢复  
如果aof文件过大,可以采用bgsave+aof融合处理恢复数据  
bgsave原理,是fork一个子进程来保存数据

# Redis的同步机制
Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。

# Redis集群
Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。

## Pipeline有什么好处，为什么要用pipeline？
可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目

# Redis雪崩、穿透和击穿
1. 缓存雪崩. 对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了,解决方案:用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 redis。如果 ehcache 和 redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 redis 中。限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？走降级！可以返回一些默认的值，或者友情提示，或者空白的值  好处：数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。

2. 缓存穿透. 对于系统A，假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到,举个栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“视缓存于无物”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死,解决方式很简单，每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 set -999 UNKNOWN。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据

3. 缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。解决方式也很简单，可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据


